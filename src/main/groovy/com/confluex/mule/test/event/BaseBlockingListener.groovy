package com.confluex.mule.test.event

import groovy.util.logging.Slf4j
import org.mule.api.MuleMessage
import org.mule.api.context.notification.ServerNotification
import org.mule.context.notification.EndpointMessageNotification
import org.slf4j.Logger
import org.slf4j.LoggerFactory

import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

abstract class BaseBlockingListener<T extends ServerNotification> {
    Logger log = LoggerFactory.getLogger(this.getClass())
    final CountDownLatch latch
    private ConcurrentLinkedQueue<MuleMessage> messageQueue = new ConcurrentLinkedQueue<MuleMessage>()

    BaseBlockingListener(Integer expectedCount = 1) {
        this.latch = new CountDownLatch(expectedCount)
    }

    abstract protected boolean matches(T notification)
    abstract protected MuleMessage getMessage(T notification)

    /**
     * Will count down the latch if the notification action is in the configured actions list.
     *
     * @param notification generated by mule
     */
    @Override
    public void onNotification(T notification) {
        if (matches(notification)) {
            putMessage getMessage(notification)
            latch.countDown()
            log.debug("Latch count={}", latch.count)
        }
    }
    /**
     * Block until the count down latch has completed or time out.
     *
     * @param timeout the number of ms to wait until we give up
     * @return true if all expected messages have flowed through. false if timed out.
     */
    public Boolean waitForMessages(long timeout = 10000) {
        log.info("Waiting for latch to release with {} messages remaining", latch.count)
        return latch.await(timeout, TimeUnit.MILLISECONDS)
    }


    public List<MuleMessage> getMessages() {
        new LinkedList<MuleMessage>(messageQueue)
    }

    protected void putMessage(MuleMessage message) {
        messageQueue.offer message
    }

}
