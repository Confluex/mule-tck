package com.confluex.mule.test.event

import groovy.util.logging.Slf4j
import org.mule.api.MuleMessage
import org.mule.api.context.notification.TransactionNotificationListener
import org.mule.context.notification.TransactionNotification
import org.mule.util.concurrent.Latch

import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

@Slf4j
class BlockingTransactionListener extends BaseBlockingEventListener<TransactionNotification> implements TransactionNotificationListener<TransactionNotification> {

    Map<String, Latch> commitLatches = [:]
    Map<String, Latch> rollbackLatches = [:]

    BlockingTransactionListener() {
        super(1)
    }

    @Override
    protected boolean matches(TransactionNotification notification) {
        log.debug "Checking notification $notification"
        return TransactionNotification.TRANSACTION_BEGAN == notification.action
    }

    @Override
    protected void onMatched(TransactionNotification notification) {
        createCommitLatch(notification.transactionStringId)
        createRollbackLatch(notification.transactionStringId)
    }
    /**
     * Will count down the appropriate Latch based on notifications of commit or rollback
     *
     * @param notification generated by mule
     */
    @Override
    public void onNotification(TransactionNotification notification) {
        super.onNotification(notification)

        if (TransactionNotification.TRANSACTION_COMMITTED == notification.action
                && commitLatches.containsKey(notification.transactionStringId)) {
            log.debug("Transaction committed: ${notification.transactionStringId}")
            commitLatches[notification.transactionStringId].release()
        }

        if (TransactionNotification.TRANSACTION_ROLLEDBACK == notification.action
                && rollbackLatches.containsKey(notification.transactionStringId)) {
            log.debug("Transaction rolled back: ${notification.transactionStringId}")
            rollbackLatches[notification.transactionStringId].release()
        }
    }

    boolean waitForCommit(String transactionId, long timeout = 10000) {
        createCommitLatch(transactionId)
        log.debug "Awaiting commit for transaction $transactionId"
        commitLatches[transactionId].await(timeout, TimeUnit.MILLISECONDS)
    }

    boolean waitForRollback(String transactionId, long timeout = 10000) {
        createRollbackLatch(transactionId)
        log.debug "Awaiting rollback for transaction $transactionId"
        rollbackLatches[transactionId].await(timeout, TimeUnit.MILLISECONDS)
    }

    private void createCommitLatch(String transactionId) {
        synchronized (commitLatches) {
            if (! commitLatches.containsKey(transactionId)) {
                commitLatches.put(transactionId, new Latch())
            }
        }
    }

    private void createRollbackLatch(String transactionId) {
        synchronized (rollbackLatches) {
            if (! rollbackLatches.containsKey(transactionId)) {
                rollbackLatches.put(transactionId, new Latch())
            }
        }
    }
}
